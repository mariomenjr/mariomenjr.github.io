[{"author":"Mario Menjívar","slug":"como-crear-un-blog-a-base-de-markdown-y-javascript","title":"Cómo crear un blog a base de markdown y javascript","timestamp":"2020-08-08T10:23:17.000-07:00","brief":"Seguramente te haz hecho la siguiente pregunta: ¿Cómo hostear mi blog sin pagar un centavo? En este post te explico una de tantas alternativas.","keywords":"javascript,svelte,blog,markdown,howto","endpoint":"2020/08/08/como-crear-un-blog-a-base-de-markdown-y-javascript","content":"\n# Cómo crear un blog a base de markdown y JavaScript\n\nSeguramente te haz hecho la siguiente pregunta: ¿Cómo hostear mi blog sin pagar un centavo? En este post te explico una de tantas alternativas.\n\n## Empecemos\n\nComo ya mencioné, hay muchas formas de lograrlo. Fundamentalmente una página web no es más que HTML, CSS y JavaScript. Herramientas como [Jekyll](https://jekyllrb.com/) aprovecha esta regla de oro para ayudarte a generar y administrar posts fácilmente.\n\nPero, ¿Qué pasa si queremos tomar ventaja de todas las herramientas disponibles en el ecosistema JavaScript que se han establecido en los últimos 10 años? Tengo 3 respuestas concretas a esa pregunta: [Gatsby](https://www.gatsbyjs.org/), [Next.js](https://nextjs.org/) y [Sapper](https://sapper.svelte.dev/docs).\n\n_In a nutshell_, estos tres frameworks permiten hacer algo muy importante para cumplir con nuestro objetivo, generar sitios estáticos. En este post nos centraremos en _Sapper_.\n\n## ¿Por qué Sapper?\n\nSvelte es el nuevo chico de la cuadra. Su propuesta insignia es mover el proceso reactivo al lenguaje, sin mediadores del tipo Virtual DOM, cómo lo hace React o Vue. Esto disminuye el tamaño del _bundle_ así cómo la velocidad de ejecución.\n\nPuedes echar un vistazo a la [comparativa](https://www.swyx.io/writing/svelte-static/) entre Gatsby y Sapper realizada por [Shawn Wang](https://twitter.com/swyx), un popular desarrollador en [egghead.io](https://egghead.io/). Se muestra una reducción del 93% en el tamaño del _bundle_ con Sapper.\n\n## Setup\n\nPara instalar Sapper, basta con ejecutar los siguientes comandos:\n\n```bash\n[user@host ~]$ npx degit \"sveltejs/sapper-template#rollup\" my-blog\n[user@host ~]$ cd my-blog\n[user@host my-blog]$ npm install\n[user@host my-blog]$ npm run dev\n```\n\nEn el folder del project _my-blog_, nos interesan los siguientes files:\n\n```text\n...\n├ src\n│ ├ routes\n| | ├ blog\n| | | ├ _posts.js\n| | | ├ [slug].json.js\n| | | ├ [slug].svelte\n| | | ├ index.json.js\n| | | ├ index.svelte\n...\n```\n\nDe paso creamos el siguiente directorio y archivo:\n\n```text\n...\n+ ├ content\n+ │ ├ 2020-08-08_hola-mundo.md\n  ├ src\n  │ ├ routes\n...\n```\n\nNecesitamos instalar los siguientes paquetes:\n\n```bash\n[user@host my-blog]$ npm i gray-matter highlight.js marked\n```\n\nEn mi caso, quiero que los posts estén ordenados por su fecha de publicación y que esto se refleje en la URL. Tendremos que hacer unos cambios a los archivos mencionados, primero renombramos dos archivos:\n\n```text\n...\n- | | | ├ [slug].json.js\n- | | | ├ [slug].svelte\n+ | | | ├ [...slug].json.js\n+ | | | ├ [...slug].svelte\n...\n```\n\nLuego, reemplazamos el contenido de la siguiente manera:\n\n```javascript\n// src/routes/blog/[...slug].json.js\n\nimport fs from \"fs\";\nimport path from \"path\";\nimport marked from \"marked\";\nimport hljs from \"highlight.js\";\nimport grayMatter from \"gray-matter\";\n\n/*\n * Para obtener el contenido del post\n */\nfunction getPost(year, month, day, fileName) {\n  return fs.readFileSync(\n    path.resolve(\"content\", `${year}-${month}-${day}_${fileName}.md`),\n    \"utf-8\"\n  );\n}\n\n/*\n * En Sapper, este método responde a una request a través del método GET\n * En nuestro caso, la request de un JSON\n */\nexport function get(req, res, next) {\n  // Así es cómo resolvemos una `dynamic route` en Sapper,\n  // obtenemos cada valor en su variable respectiva\n  let [year, month, day, slug] = req.params.slug;\n\n  const postMarkdown = getPost(year, month, day, slug);\n  const renderer = new marked.Renderer();\n\n  // marked provee una manera de formatear partes específicas del markdown\n  // en este caso, el código\n  renderer.code = (source, lang) => {\n    const { value: highlighted } = hljs.highlight(lang, source);\n    return `<pre class='language-${lang} overflow-x-auto'><code>${highlighted}</code></pre>`;\n  };\n\n  marked.use({ renderer });\n\n  const { data, content } = grayMatter(postMarkdown);\n  const html = marked(content);\n\n  if (html) {\n    res.writeHead(200, { \"Content-Type\": \"application/json\" });\n    res.end(JSON.stringify({ html, ...data }));\n  } else {\n    res.writeHead(404, { \"Content-Type\": \"application/json\" });\n    res.end(JSON.stringify({ message: `Not found` }));\n  }\n}\n```\n```html\n<!-- src/routes/blog/[...slug].svelte -->\n\n<script context=\"module\">\n  /*\n   * Este método representa un paso en el ciclo de vida de un component en Sapper.\n   *\n   * Únicamente se ejecuta cuando el componente es montado. Aquí haremos la petición de nuestro JSON con la información del post\n   */\n  export async function preload({ params }) {\n    let [year, month, day, slug] = params.slug;\n\n    const res = await this.fetch(`blog/${year}/${month}/${day}/${slug}.json`);\n    const data = await res.json();\n\n    if (res.status === 200) {\n      return { post: data };\n    } else {\n      this.error(res.status, data.message);\n    }\n  }\n</script>\n\n<script>\n  export let post;\n</script>\n\n<svelte:head>\n  <title>{post.title} by {post.author}</title>\n</svelte:head>\n\n<article>\n  {@html post.html}\n</article>\n```\n\nAcabamos de programar cómo se renderizará el post. Ya deberías poder verlo en [/blog/2020/08/08/hola-mundo](http://localhost:3000/blog/2020/08/08/hola-mundo) en tu local.\n\nPodrías pensar que ya terminamos, pero hay un pequeño detalle que debemos cubrir para cumplir con las reglas de Sapper si queremos exportar nuestro pequeño blog como un sitio estático.\n\n> \"... any pages you want to be included in the exported site must either be reachable by \\<a\\> elements or added to the --entry option of the sapper export command.\"\n> at [sapper-export](https://sapper.svelte.dev/docs#How_it_works)\n\nDe acuerdo a la documentación, debemos incluir elementos **\\<a\\>** que apunten a nuestras páginas generadas a partir de rutas dinámicas para que al exportar el sitio, estas también se incluyan. Por eso programaremos el endpoint [/blog](http://localhost:3000/blog).\n\n```javascript\n// src/routes/blog/index.json.js\n\nimport fs from \"fs\";\nimport path from \"path\";\nimport grayMatter from \"gray-matter\";\n\nfunction getAllPosts() {\n  const posts = fs\n    .readdirSync(\"content\")\n    .map((fileName) => {\n      const post = fs.readFileSync(path.resolve(\"content\", fileName), \"utf-8\");\n      return grayMatter(post).data;\n    })\n    .sort((a, b) => {\n      if (b.timestamp < a.timestamp) return -1;\n      if (b.timestamp > a.timestamp) return 1;\n\n      return 0;\n    });\n  return posts;\n}\n\nexport function get(req, res) {\n  res.writeHead(200, { \"Content-Type\": \"application/json\" });\n  res.end(JSON.stringify(getAllPosts()));\n}\n```\n```html\n<!-- src/routes/blog/index.svelte -->\n\n<script context=\"module\">\n  export function preload({ params, query }) {\n    return this.fetch(`blog.json`)\n      .then((r) => r.json())\n      .then((posts) => ({\n        posts: posts.map((post) => {\n          const timestamp = new Date(post.timestamp);\n          return {\n            ...post,\n            timestamp,\n            date: {\n              year: timestamp.getFullYear(),\n              month: `${timestamp.getMonth() + 1}`.padStart(2, `0`),\n              day: `${timestamp.getDate()}`.padStart(2, `0`),\n            },\n          };\n        }),\n      }));\n  }\n</script>\n\n<script>\n  export let posts;\n</script>\n\n<svelte:head>\n  <title>Blog | Mario Menjívar</title>\n</svelte:head>\n\n<ul>\n  {#each posts as post}\n  <li>\n    <a\n      rel=\"prefetch\"\n      href=\"blog/{post.date.year}/{post.date.month}/{post.date.day}/{post.slug}\"\n    >\n      {post.title}\n    </a>\n    <p class=\"c-label-last-updated\">\n      Posted on {post.timestamp.toLocaleString()} by {post.author}\n    </p>\n  </li>\n  {/each}\n</ul>\n```\n\nListo.\n\n## Sitio estático\n\nAntes de desplegar nuestro fantástico blog, necesitamos asegurarnos que las páginas estáticas se generaran sin problemas. Para eso necesitamos ejecutar lo siguiente en la línea de comandos:\n\n```bash\n[user@host my-blog]$ npm run export\n[user@host my-blog]$ npx serve __sapper__/export\n```\n\nSi no tienes ningun problema al acceder a este endpoint [/blog/2020/08/08/hola-mundo](http://localhost:5000/blog/2020/08/08/hola-mundo), ¡Felicidades! solo nos falta desplegar.\n\n\n## Despliegue: Github Pages\n\nEn este punto, podríamos copiar la carpeta \\_\\_sapper\\_\\_/export y llevarla a cualquier CDN para ser servido. Por ejemplo, Netlify o Github Pages. En este post te mostraré cómo hacerlo con Github Pages.\n\n\n... pero hacerlo de manera manual, en mi opinión, le quita la diversión."}]