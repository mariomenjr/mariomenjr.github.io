[{"author":"Mario Menjívar","slug":"como-validar-formularios-en-react-sin-lagrimas","title":"Cómo validar formularios en React, sin lágrimas","timestamp":"2020-09-04T07:08:02.000-07:00","brief":"Históricamente, validar un formulario en React requiere de una cantidad impresionante de boilerplate que añade complejidad innecesaria. Veamos cómo librarnos de eso.","keywords":"formik,español,react,cómo,validar formularios react,binaria,blog","cover":"https://imgur.com/wm6iA0l.png","endpoint":"2020/09/04/como-validar-formularios-en-react-sin-lagrimas","content":"\n# Cómo validar formularios en React, sin lágrimas\n\nTodos los desarrolladores de software que trabajamos con React, absolutamente todos, hemos tenido ese tedioso ticket para crear y/o validar un formulario. Afortunadamente para ti, hoy te mostraré la forma más sencilla de cerrarlo: Formik.\n\n## Formik what?\n\n[Formik](https://formik.org/docs/overview) es uno de los paquetes de software de código abierto más útiles que podemos encontrar en el repositorio de `npm` (o `yarn`, como gustes). En palabras de uno de sus creadores, [@JaredPalmer](https://twitter.com/jaredpalmer):\n\n> \"Admítamoslo, los formularios requiren de muchísimo código en React. Para poner las cosas peor, la mayoría de utilidades para construirlos hacen muchísima, demasiada magia que frecuentemente trae un costo al desempeño\" de [Formik Docs](https://formik.org/docs/overview)\n\nPara Jared y compañía había un beneficio en estandarizar los componentes de entrada y cómo los datos fluían a través del Form. Es la razón de ser de Formik.\n\n## Preparando el ejemplo\n\nPara ser prácticos, vamos a hacer uso del famosísimo toolchain `create-react-app`. Ve a tu línea de comandos y ejecuta:\n\n```bash\n$ npx create-react-app formik-sample\n$ cd formik-sample\n$ npm start\n```\n\n![React App by create-react-app](https://imgur.com/8tQZ4qO.png)\n\nAhora tenemos la base para trabajar nuestra aplicación React, pero necesitamos un form al cuál validar, para eso instalaremos el siguiente paquete:\n\n```bash\n$ npm install bootstrap reactstrap --save\n```\n\nEste paquete componetiza la mayoría de utilidades del popular framework CSS Bootstrap, lo cuál acelera nuestra habilidad de construir el layout del formulario. Una vez completa la instalación, copia y pega este código en tu archivo `src/App.js`:\n\n```javascript\n// src/App.js\n\nimport React from \"react\";\nimport {\n  Container,\n  Button,\n  Form,\n  FormGroup,\n  Label,\n  Input,\n  Card,\n  CardBody,\n  CardHeader,\n  FormFeedback,\n} from \"reactstrap\";\n\nfunction Formulario() {\n  return (\n    <Container className=\"p-5\">\n      <Card>\n        <CardHeader></CardHeader>\n        <CardBody>\n          <Form>\n            <h1>Form</h1>\n            <FormGroup>\n              <Label for=\"name\">Name</Label>\n              <Input type=\"text\" name=\"name\" placeholder=\"Woody Allen\" />\n            </FormGroup>\n            <FormGroup>\n              <Label for=\"email\">Email</Label>\n              <Input\n                type=\"email\"\n                name=\"email\"\n                placeholder=\"contoso@domain.com\"\n              />\n            </FormGroup>\n            <FormGroup>\n              <Label for=\"password\">Password</Label>\n              <Input\n                type=\"password\"\n                name=\"password\"\n                placeholder=\"Provide a password\"\n              />\n            </FormGroup>\n            <FormGroup>\n              <Label for=\"bio\">Text Area</Label>\n              <Input type=\"textarea\" name=\"bio\" />\n            </FormGroup>\n\n            <Button type=\"submit\">Submit</Button>\n          </Form>\n        </CardBody>\n      </Card>\n    </Container>\n  );\n}\n\nexport default Formulario;\n```\n\nTambién, añade está línea en el archivo `src/index.js`:\n\n```javascript\n// src/index.js\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'bootstrap/dist/css/bootstrap.css'; // Importa bootstrap a la React App\n// ...\n```\n\nDeberías ver un formulario similar al de la imagen:\n\n![Form built with reactstrap](https://imgur.com/6NWfclG.png)\n\nContinuemos.\n\n## Formik\n\nLlegados a este punto, ya estamos listos para ver la magia de Formik.\n\n```bash\n$ npm install formik --save\n```\n\nYa que la instalación haya finalizado, vamos a hacer unas modificaciones a nuestro código en `src/App.js`.\n\n```javascript\n// src/App.js\n\nimport React from \"react\";\nimport { Formik } from \"formik\"; // Importamos el component <Formik />\nimport {\n  Container,\n// ...\n```\n\nEste componente debe encapsular a nuestro formulario, cómo se muestra abajo. Formik se mantiene al tanto del estado del formulario y te provee valores, métodos reusables y manejadores de eventos a través de `props`.\n\nAdemás, Formik sigue una regla básica para simplificar el proceso de validación. Para que la librería puede relacionar un `initialValues` a un `<Input>` específico, tanto la propiedad como el `name` de `<Input>` deben tener el mismo nombre. En el ejemplo de abajo, hemos definido 5 controles: `name`, `email`, `password`, `bio`, and `multiple`.\n\nAunque no debemos olvidar que estamos en React, por lo qué debemos manejar el cambio de los valores de los controles. Esto lo logramos con los manejadores provistos por Formik: `handleChange` y `handleBlur`. Sin olvidar que debemos renderizar el valor adecuado en el control, para eso haremos uso de la propiedad `values`.\n\nAparte de las útiles `props` provistas por Formik, también el tag en sí mismo necesita de ciertas propiedades para funcionar:\n\n- `initialValues`: Le dice a Formik de cuales valores debe mantenerse al tanto y buscar sus respectivos controles en el formulario.\n- `validate`: Esta función recibe como parametro los `values` de los cuáles la librería está al tanto para ser validados.\n- `onSubmit`: Quizá la función que más te interese de la librería. Es aquí dónde definimos que debe suceder si nuestro formulario ha sido validado con éxito. Por ejemplo, postear los valores a un servicio del backend.\n\nYa qué hemos cubierto una breve explicación, es hora de ver todo esto en código.\n\n```javascript\n// src/App.js\n\n// ...\nfunction Formulario() {\n  return (\n    <Container className=\"p-5\">\n      <Card>\n        <CardHeader></CardHeader>\n        <CardBody>\n          <Formik\n            initialValues={{\n              name: \"\",\n              email: \"\",\n              password: \"\",\n              bio: \"\",\n            }}\n            validate={(values) => {\n              const errors = {};\n\n              // We need a name\n              if (!values.name) errors.name = \"Required\";\n\n              // We need a valid e-mail\n              if (!values.email) errors.email = \"Required\";\n              else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$/i.test(values.email))\n                errors.email = \"Invalid email address\";\n\n              // We need a valid password\n              if (!values.password) errors.password = \"Required\";\n              else if (`${values.password}`.length < 7)\n                errors.password =\n                  \"Password must be larger than 7 characters\";\n\n              console.log({ values, errors });\n\n              return errors;\n            }}\n            onSubmit={(values, { setSubmitting }) => {\n              setTimeout(() => {\n                alert(JSON.stringify(values, null, 2));\n\n                setSubmitting(false);\n              }, 250);\n            }}\n          >\n            {(props) => {\n              const {\n                values,\n                errors,\n                touched,\n                handleChange,\n                handleBlur,\n                handleSubmit,\n                isSubmitting,\n                /* y otras más */\n              } = props;\n              return (\n                <Form onSubmit={handleSubmit}>\n                  <h1>Form</h1>\n                  <FormGroup>\n                    <Label for=\"name\">Name</Label>\n                    <Input\n                      type=\"text\"\n                      name=\"name\"\n                      placeholder=\"Woody Allen\"\n                      invalid={errors.name && touched.name}\n                      onChange={handleChange}\n                      onBlur={handleBlur}\n                      value={values.name}\n                    />\n                    <FormFeedback>{errors.name}</FormFeedback>\n                  </FormGroup>\n                  <FormGroup>\n                    <Label for=\"email\">Email</Label>\n                    <Input\n                      type=\"email\"\n                      name=\"email\"\n                      placeholder=\"contoso@domain.com\"\n                      invalid={errors.email && touched.email}\n                      onChange={handleChange}\n                      onBlur={handleBlur}\n                      value={values.email}\n                    />\n                    <FormFeedback>{errors.email}</FormFeedback>\n                  </FormGroup>\n                  <FormGroup>\n                    <Label for=\"password\">Password</Label>\n                    <Input\n                      type=\"password\"\n                      name=\"password\"\n                      placeholder=\"Provide a password\"\n                      invalid={errors.password && touched.password}\n                      onChange={handleChange}\n                      onBlur={handleBlur}\n                      value={values.password}\n                    />\n                    <FormFeedback>{errors.password}</FormFeedback>\n                  </FormGroup>\n                  <FormGroup>\n                    <Label for=\"bio\">Text Area</Label>\n                    <Input\n                      type=\"textarea\"\n                      name=\"bio\"\n                      onChange={handleChange}\n                      onBlur={handleBlur}\n                      value={values.name}\n                    />\n                  </FormGroup>\n\n                  <Button type=\"submit\" disabled={isSubmitting}>\n                    {isSubmitting ? `Loading` : `Submit`}\n                  </Button>\n                </Form>\n              );\n            }}\n          </Formik>\n        </CardBody>\n      </Card>\n    </Container>\n  );\n}\n// ...\n```\n\nEl código de arriba nos permite validar el nombre, e-mail y contraseña en nuestro formulario. Al hacer clic en `Submit`, sin completar un solo `<Input>`, deberías ver algo similar a esto:\n\n![Formulario validado](https://imgur.com/IIVx4c9.png)\n\nListo, ya hemos validado el formulario. Lo único que nos queda es definir el manejador `onSubmit` en el tag `Formik` y tendremos la certeza de qué si nuestro programa ejecuta ese `callback` se debe a que nuestros datos han sido previamente validados.\n\n## Podemos hacerlo mejor\n\nSeguramente tienes alguna de estas preguntas en tu cabeza: ¿Por qué repetir la asignación de `handleChange` y `handleBlur`? y ¿Por qué validar _manualmente_ cada propiedad paso a paso?. Creéme, yo también me hice esas preguntas.\n\nPara fortuna de quién tenga que mantener este formulario, hay una forma más sencilla de definir las validación y los controles de estado.\n\n### Formik Field\n\nPara reducir el número de veces que repetimos la asignación de los manejadores de eventos, vamos a importar otro elemento de la librería Formik.\n\n```javascript\n// src/App.js\n\n// ...\nimport { Formik, Field } from \"formik\"; // Importamos el component <Field />\n// ...\n```\n\nEste componente nos permite ahorrarnos la asignación de manejadores y valor directamente al componente. Lo único que debemos hacer, y ya que estamos usando `reacstrap`, es asignarlo a la propiedad `tag` de cada elemento `<Input>`. Formik se encargará del resto.\n\n```javascript\n<Input\n  type=\"text\"\n  name=\"name\"\n  placeholder=\"Woody Allen\"\n  invalid={errors.name && touched.name}\n- onChange={handleChange}\n- onBlur={handleBlur}\n- value={values.name}\n+ tag={Field}\n/>\n```\n\nEs imprescindible que la propiedad `name` del `<Input>` tenga el mismo nombre a una propiedad en `initialValues`.\n\n### Formik + Yup\n\n[`Yup`](https://github.com/jquense/yup) es una librería que nos permite construir esquemas de conversión y validación. El punto más fuerte de `Yup` es el nível de expresividad que las validaciones pueden alcanzar, sencillas o complejas.\n\nDe acuerdo a la [documentación](https://formik.org/docs/guides/validation#validationschema) de `Formik`, `Yup` es un ciudadano de primera clase en la librería por lo que posee una `prop` especial en el elemento `<Formik>` llamada `validationSchema`.\n\n```bash\n$ npm install yup --save\n```\n\nUna vez instalamos `Yup`, debemos importarlo:\n\n```javascript\n// src/App.js\n\n// ...\nimport * as Yup from \"yup\"; // Importando Yup\nimport {\n  Container,\n// ...\n```\n\nRegresemos al código del componente `Formulario`. Justo en la propiedades del elmento `<Formik>` vamos a eliminar la propiedad `validate` y en su lugar asignaremos la propiedad `validationSchema`.\n\n```javascript\n<Formik\n  initialValues={{\n    name: \"\",\n    email: \"\",\n    password: \"\",\n    bio: \"\",\n  }}\n  validationSchema={Yup.object().shape({\n    name: Yup.string().required(\"Required\"),\n    email: Yup.string().email(\"Invalid email\").required(\"Required\"),\n    password: Yup.string().min(8, \"Password is too short\").required(\"Required\"),\n  })}\n  onSubmit={(values, { setSubmitting }) => {\n    setTimeout(() => {\n      alert(JSON.stringify(values, null, 2));\n\n      setSubmitting(false);\n    }, 250);\n  }}\n>\n```\n\nPor último, podemos llenar nuestro formulario y ver que una vez validado, el `callback` en la propiedad `onSubmit` del elemento `<Formik>` es ejecutada.\n\n![Formulario completo](https://imgur.com/wm6iA0l.png)\n\n## Conclusión\n\nEspero este post te sea de mucha ayuda. En mi experiencia con React, Formik me ha facilitado el validar formularios al proveerme de métodos que me permiten ajustar a cada momento los valores y las validaciones necesarias. La expresividad del código es de gran valor ya que permite escalar y/o mantener de una forma sencilla sin reinventar la rueda para cada formulario.\n\n## Referencias\n\n- [Formik documentation](https://formik.org/docs/overview)"},{"author":"Mario Menjívar","slug":"algoritmos-busqueda-binaria","title":"#Algoritmos: Búsqueda binaria","timestamp":"2020-08-14T09:47:12.000-07:00","brief":"A qué alguna vez te toco buscar un número de teléfono en aquellos gigantescos directorios teléfonicos, ¿Cómo le hacías, página por página o te tratabas de ahorrar tiempo saltándote páginas?","keywords":"algoritmos,computer,science,busqueda,binaria,blog,ciencias,computacion","cover":"https://upload.wikimedia.org/wikipedia/commons/f/f7/Binary_search_into_array.png","endpoint":"2020/08/14/algoritmos-busqueda-binaria","content":"\n# \\#Algoritmos: Búsqueda binaria\n\nA qué alguna vez te toco buscar un número de teléfono en aquellos gigantescos directorios teléfonicos, ¿Cómo le hacías, página por página o tratabas de ahorrar tiempo saltándote páginas?\n\n## La idea\n\nRetomando el gigantesco directorio teléfonico, podemos estar seguros de una cosa: los números de teléfono se presentan en orden alfabético por el nombre del propietario. Esto es es imprecindible para el algoritmo de búsqueda binaria. \n\nSuponiendo que buscamos el número teléfonico de Juan, ¿Tiene sentido empezar desde las primeras páginas dónde estarán los números de personas cómo Alberto o Alejandra? Si tu respuesta es no, estás en lo correcto, será muchísimo más fácil identificar en cuál página empiezan a listarse los nombres que inician con J, y empezar nuestra búsqueda desde ahí. Una vez en esta página, podríamos incluso tratar de idéntificar en cuál página empiezan a listarse los nombres que empiezan con Ju, y así sucesivamente hasta encontrar a Juan.\n\n## En código\n\nPero en este blog nosotros ya no usamos esos gigantescos directorios teléfonicos, así que vamos a ver un ejemplo más acorde a lo que sabemos hacer aquí: código. Por lo qué para nuestro ejemplo práctico, vamos a validar si un número `X` está incluído dentro de una lista de `N` elementos.\n\nComo mencionamos antes en el ejemplo del directorio, podíamos estar seguros de una cosa: sus datos están ordenados. Esto se mantiene a la hora de utilizar código. Nuestro arreglo de datos debe estar ordenado. Sino lo está, debemos ordenarlo. Eso lo dejaremos para futuros posts.\n\nEsta será nuestra lista de trabajo:\n\n```javascript\nconst numbers = [2, 3, 5, 9, 15, 17, 55, 69];\n```\n\nPara ejecutar de manera efectiva el algoritmo, necesitaremos tener la noción del mayor y menor número en nuestra lista, y ya qué no hay mejor manera de localizar valores en una lista que usar su indice, guardaremos eso, los indices:\n\n```javascript\nlet maxIndex = numbers.length - 1;\nlet minIndex = 0;\n```\n\n¿Recuerdas como en el ejemplo del directorio, tratabamos de identificar la página en la cuál los nombres que inician con J empezaban a listarse? Al aplicar el algoritmo de búsqueda binaria tomamos un enfoque más general. Esto significa que nosotros siempre dividiremos la lista por la mitad y, partiendo de una comparación, definiremos a cuál de las dos mitades pertence el valor que deseamos encontrar. Una vez conozcamos la mitad a la qué pertenece, repetimos el proceso y así sucesivamente hasta que nuestra área de búsqueda se reduce a uno, o simplemente no encontramos el valor.\n\n> ![Búsqueda binaria](https://upload.wikimedia.org/wikipedia/commons/f/f7/Binary_search_into_array.png)\n> Este es el esquema del funcionamiento del algoritmo de [Wikipedia](https://es.wikipedia.org/wiki/B%C3%BAsqueda_binaria)\n\nAntes de ejemplificar lo anterior, nos queda mostrar cómo identificaremos la mitad de nuestra lista:\n\n```javascript\nlet half = Math.floor((minIndex + maxIndex)/2);\n```\n\nAhora sí, armemos el algoritmo:\n\n```javascript\nconst find = 17;\nconst numbers = [2, 3, 5, 9, 15, 17, 55, 69];\n\nfunction busquedaBinaria(collection, findee) {\n  // Asignando los valores del rango inicial\n  let minIndex = 0;\n  let maxIndex = numbers.length - 1;\n\n  while (minIndex <= maxIndex) {\n    \n    // Calculando la posición en el medio de la lista\n    let half = Math.floor((minIndex + maxIndex) / 2);\n\n    // Recoger el valor del medio\n    let guess = collection[half];\n\n    if (guess === findee) // Comparamos si es el valor que buscamos\n      return half;\n\n    else if (guess > findee) \n      // Si el valor que buscamos es menor al valor supuesto\n      // debemos reducir nuestro rango de búsqueda.\n      // Ahora nuestro mayor valor está justo debajo de la mitad calculada.\n      maxIndex = half - 1; \n    \n    else \n      // Si el valor que buscamos es mayor al valor supuesto\n      // debemos reducir nuestro rango de búsqueda.\n      // Ahora nuestro menor valor está justo arriba de la mitad calculada.\n      minIndex = half + 1;\n  }\n  return -1;\n}\n\nconst foundIndex = busquedaBinaria(numbers, find);\nconsole.log(\n  foundIndex === -1\n    ? `El número ${find} no fue encontrado.`\n    : `El número ${find} está en el índice ${foundIndex}.`\n);\n```\n\nEs esta dinámica de decidir únicamente entre dos opciones, cada vez que reducimos el área de búsqueda, lo qué le da el nombre algoritmo.\n\n# Conclusión\n\nPudimos simplemente ejecutar el siguiente código:\n\n```javascript\nconst find = 17;\nconst numbers = [2, 3, 5, 9, 15, 17, 55, 69];\n\nlet foundIndex = -1;\n\nfor (let index = 0; index < numbers.length; index++) {\n  if (find === numbers[index]) {\n    foundIndex = index;\n    break;\n  }\n}\n\nconsole.log(\n  foundIndex === -1\n    ? `El número ${find} no fue encontrado.`\n    : `El número ${find} está en el índice ${foundIndex}.`\n);\n```\n\nComparar cada uno de los `items` en la lista y, cuando lo encontramos, listo. Podrías pensar que es enfoque es muchísimo más fácil y rápido de programar, y tienes razón. Pero, ¿Qué pasa cuando nuestra lista no contiene 8 `items` sino 1,000,000?\n\nLa intención de este post es mostrarte que, si bien es cierto en programación hay muchas formas de resolver un problema, nuestro objetivo conforme avanzamos en nuestra carrera es escogar la más óptima. Cada problema es un mundo y es nuestro trabajo encontrar la mejor solución.\n\n# Referencias\n\n- [Binary search algorithm from Wikipedia](https://en.wikipedia.org/wiki/Binary_search_algorithm)\n- [Grokking Algorithms: An Illustrated Guide For Programmers and Other Curious People](https://www.goodreads.com/book/show/22847284-grokking-algorithms-an-illustrated-guide-for-programmers-and-other-curio)"},{"author":"Mario Menjívar","slug":"como-crear-un-blog-a-base-de-markdown-y-javascript","title":"Cómo crear un blog a base de markdown y JavaScript","timestamp":"2020-08-09T10:23:17.000-07:00","brief":"Seguramente te haz hecho la siguiente pregunta: ¿Cómo hostear un blog que sea fácil de mantener, sin pagar un centavo? En este post te explico una de tantas alternativas.","keywords":"javascript,svelte,blog,markdown,howto","endpoint":"2020/08/09/como-crear-un-blog-a-base-de-markdown-y-javascript","content":"\n# Cómo crear un blog a base de markdown y JavaScript\n\nSeguramente te haz hecho la siguiente pregunta: ¿Cómo hostear un blog que sea fácil de mantener, sin pagar un centavo? En este post te explico una de tantas alternativas.\n\n## Porqué\n\nOtra pregunta que probablemente este en tu cabeza es ¿Por qué markdown y JavaScript? La respuesta es un poco más elaborada. Para empezar, ¿Qué es markdown? Según Wikipedia: \n\n> \"Markdown es un lenguaje de marcado ligero que trata de conseguir la máxima legibilidad y facilidad de publicación tanto en su forma de entrada como de salida, inspirándose en muchas convenciones existentes para marcar mensajes de correo electrónico usando texto plano\" de [Wikipedia](https://es.wikipedia.org/wiki/Markdown).\n\nAl usar markdown para escribir un post, estamos estructurando nuestro contenido sin necesidad de incluir HTML o CSS en el momento. Es decir, nos enfocamos enteramente en lo importante: el texto. Esta simplicidad se verá potencializada al incluir _Git_ y _Github_ en la formula, ya que podremos versionar nuestro contenido.\n\nComo mencioné, hay muchas alternativas para lograrlo. Fundamentalmente una página web no es más que HTML, CSS y JavaScript. Herramientas como [_Jekyll_](https://jekyllrb.com/), aprovechan esta regla de oro para ayudarte a generar y administrar posts fácilmente haciendo uso de markdown. Pero, ¿Qué pasa si queremos tomar ventaja de todas las herramientas disponibles en el ecosistema JavaScript que se han establecido en los últimos 10 años?  Para eso tenemos [_Gatsby_](https://www.gatsbyjs.org/), [_Next.js_](https://nextjs.org/) o [_Sapper_](https://sapper.svelte.dev/docs).\n\n_In a nutshell_, estos tres frameworks permiten generar sitios estáticos haciendo uso de herramientas modernas como React o Svelte. En este post nos centraremos en _Sapper_.\n\n## ¿Por qué _Sapper_?\n\nSvelte es el nuevo chico de la cuadra. Su propuesta insignia es mover la reactividad de la UI desde mediadores como el Virtual DOM hacia el lenguaje, o mejor dicho, al compilador, en contraste con React o Vue. Esto aumenta el desempeño de las aplicaciones y disminuye el tamaño del _bundle_.\n\nPuedes echar un vistazo a la [comparativa](https://www.swyx.io/writing/svelte-static/) entre Gatsby y Sapper realizada por [Shawn Wang](https://twitter.com/swyx), un popular desarrollador en [egghead.io](https://egghead.io/). Se muestra una reducción del 93% en el tamaño del _bundle_ con _Sapper_.\n\n## Setup\n\nPara instalar Sapper, basta con ejecutar los siguientes comandos:\n\n```bash\n[user@host ~]$ npx degit \"sveltejs/sapper-template#rollup\" my-blog\n[user@host ~]$ cd my-blog\n[user@host my-blog]$ npm install\n[user@host my-blog]$ npm run dev\n```\n\nEn el folder del projecto _my-blog_, nos interesan los siguientes files:\n\n```text\n...\n├ src\n│ ├ routes\n| | ├ blog\n| | | ├ _posts.js\n| | | ├ [slug].json.js\n| | | ├ [slug].svelte\n| | | ├ index.json.js\n| | | ├ index.svelte\n...\n```\n\nDe paso creamos el siguiente directorio y archivo:\n\n```text\n...\n+ ├ content\n+ │ ├ 2020-08-08_hola-mundo.md\n  ├ src\n  │ ├ routes\n...\n```\n\nCon el siguiente contenido:\n\n```text\n---\nauthor: 'Mario Menjívar'\nslug: 'hola-mundo'\ntitle: 'Hola Mundo'\ntimestamp: '2020-08-08T10:23:17.000-07:00'\n---\n\n# Hola mundo\n\nHola mundo.\n```\n\nNecesitamos instalar los siguientes paquetes:\n\n```bash\n[user@host my-blog]$ npm i gray-matter highlight.js marked\n```\n\nEn mi caso, quiero que los posts estén ordenados por su fecha de publicación y que esto se refleje en la URL. Tendremos que hacer unos cambios a los siguientes archivos:\n\n```text\n...\n- | | | ├ [slug].json.js\n- | | | ├ [slug].svelte\n+ | | | ├ [...slug].json.js\n+ | | | ├ [...slug].svelte\n...\n```\n\nLuego, reemplazamos el contenido:\n\n```javascript\n// src/routes/blog/[...slug].json.js\n\nimport fs from \"fs\";\nimport path from \"path\";\nimport marked from \"marked\";\nimport hljs from \"highlight.js\";\nimport grayMatter from \"gray-matter\";\n\n/*\n * Para obtener el contenido del post\n */\nfunction getPost(year, month, day, fileName) {\n  return fs.readFileSync(\n    path.resolve(\"content\", `${year}-${month}-${day}_${fileName}.md`),\n    \"utf-8\"\n  );\n}\n\n/*\n * En Sapper, este método responde a una request a través del método GET\n * En nuestro caso, la request de un JSON\n */\nexport function get(req, res, next) {\n  // Así es cómo resolvemos una `dynamic route` en Sapper,\n  // obtenemos cada valor en su variable respectiva\n  let [year, month, day, slug] = req.params.slug;\n\n  const postMarkdown = getPost(year, month, day, slug);\n  const renderer = new marked.Renderer();\n\n  // marked provee una manera de formatear partes específicas del markdown\n  // en este caso, el código\n  renderer.code = (source, lang) => {\n    const { value: highlighted } = hljs.highlight(lang, source);\n    return `<pre class='language-${lang} overflow-x-auto'><code>${highlighted}</code></pre>`;\n  };\n\n  marked.use({ renderer });\n\n  const { data, content } = grayMatter(postMarkdown);\n  const html = marked(content);\n\n  if (html) {\n    res.writeHead(200, { \"Content-Type\": \"application/json\" });\n    res.end(JSON.stringify({ html, ...data }));\n  } else {\n    res.writeHead(404, { \"Content-Type\": \"application/json\" });\n    res.end(JSON.stringify({ message: `Not found` }));\n  }\n}\n```\n```html\n<!-- src/routes/blog/[...slug].svelte -->\n\n<script context=\"module\">\n  /*\n   * Este método representa un paso en el ciclo de vida de un component en Sapper.\n   *\n   * Únicamente se ejecuta cuando el componente es montado. Aquí haremos la petición de nuestro JSON con la información del post\n   */\n  export async function preload({ params }) {\n    let [year, month, day, slug] = params.slug;\n\n    const res = await this.fetch(`blog/${year}/${month}/${day}/${slug}.json`);\n    const data = await res.json();\n\n    if (res.status === 200) {\n      return { post: data };\n    } else {\n      this.error(res.status, data.message);\n    }\n  }\n</script>\n\n<script>\n  export let post;\n</script>\n\n<svelte:head>\n  <title>{post.title} by {post.author}</title>\n</svelte:head>\n\n<article>\n  {@html post.html}\n</article>\n```\n\nDe esta forma se renderizará el post. Ya puedes verlo en tu ambiente local yendo a [/blog/2020/08/08/hola-mundo](http://localhost:3000/blog/2020/08/08/hola-mundo).\n\nAún hay un pequeño detalle que debemos cubrir para cumplir con las reglas que _Sapper_ establece si queremos exportar nuestro pequeño blog como un sitio estático.\n\n> \"... cualquier página que quieras que sea incluída en el sitio (estático) exportado debe ser esta ligado con una etiqueta del tipo \\<a\\> o añadida cómo parametro de la opción  --entry del comando `sapper export`\" de [Sapper docs](https://sapper.svelte.dev/docs#How_it_works).\n\nDe acuerdo a la documentación, debemos incluir elementos **\\<a\\>** que apunten a nuestras páginas generadas a partir de rutas dinámicas, para que al exportar el sitio estas también se incluyan. Por eso programaremos el endpoint [/blog](http://localhost:3000/blog).\n\n```javascript\n// src/routes/blog/index.json.js\n\nimport fs from \"fs\";\nimport path from \"path\";\nimport grayMatter from \"gray-matter\";\n\nfunction getAllPosts() {\n  const posts = fs\n    .readdirSync(\"content\")\n    .map((fileName) => {\n      const post = fs.readFileSync(path.resolve(\"content\", fileName), \"utf-8\");\n      return grayMatter(post).data;\n    })\n    .sort((a, b) => {\n      if (b.timestamp < a.timestamp) return -1;\n      if (b.timestamp > a.timestamp) return 1;\n\n      return 0;\n    });\n  return posts;\n}\n\nexport function get(req, res) {\n  res.writeHead(200, { \"Content-Type\": \"application/json\" });\n  res.end(JSON.stringify(getAllPosts()));\n}\n```\n```html\n<!-- src/routes/blog/index.svelte -->\n\n<script context=\"module\">\n  export function preload({ params, query }) {\n    return this.fetch(`blog.json`)\n      .then((r) => r.json())\n      .then((posts) => ({\n        posts: posts.map((post) => {\n          const timestamp = new Date(post.timestamp);\n          return {\n            ...post,\n            timestamp,\n            date: {\n              year: timestamp.getFullYear(),\n              month: `${timestamp.getMonth() + 1}`.padStart(2, `0`),\n              day: `${timestamp.getDate()}`.padStart(2, `0`),\n            },\n          };\n        }),\n      }));\n  }\n</script>\n\n<script>\n  export let posts;\n</script>\n\n<svelte:head>\n  <title>Blog | Mario Menjívar</title>\n</svelte:head>\n\n<ul>\n  {#each posts as post}\n  <li>\n    <a\n      rel=\"prefetch\"\n      href=\"blog/{post.date.year}/{post.date.month}/{post.date.day}/{post.slug}\"\n    >\n      {post.title}\n    </a>\n    <p class=\"blog-timestamp\">\n      Posted on {post.timestamp.toLocaleString()} by {post.author}\n    </p>\n  </li>\n  {/each}\n</ul>\n```\n\nListo.\n\n## Sitio estático\n\nAntes de desplegar nuestro fantástico blog, necesitamos asegurarnos que las páginas estáticas se generaran sin problemas. Para eso necesitamos ejecutar lo siguiente en la línea de comandos:\n\n```bash\n[user@host my-blog]$ npm run export\n[user@host my-blog]$ npx serve __sapper__/export\n```\n\nSi no tienes ningun problema al acceder a este endpoint [/blog/2020/08/08/hola-mundo](http://localhost:5000/blog/2020/08/08/hola-mundo), ¡Felicidades! solo nos queda desplegar el sitio.\n\n\n## Despliegue: Github Pages\n\nNuestro sitio estático ha sido generado y los archivos están dentro de la carpeta `__sapper__/export`. Existen una infinidad de servicios que te permiten almacenar y servir este tipo de sitios, entre los más populares tenemos Netlify o Github Pages. En este post te mostraré cómo hacerlo con _Github Pages_.\n\nPodríamos subir el folder `__sapper__/export` a un nuevo repositorio, activar la opción _Github Pages_ y repetir este proceso manualmente cada vez que actualicemos nuestro sitio con un nuevo post. En mi opinión, hacerlo de manera manual le quita la diversión. Afortunadamente, exite _Github Actions_.\n\nEl primer paso es crear dos repositorios en _Github_, el primero es el repositorio de nuestro projecto y el segundo el repositorio al cuál subiremos nuestro sitio estático. En mi caso, [mariomenjr/mariomenjr](https://github.com/mariomenjr/mariomenjr) y [mariomenjr/mariomenjr.github.io](https://github.com/mariomenjr/mariomenjr.github.io) respectivamente. Una vez hecho esto, creamos los siguientes folders y archivos en el folder del projecto:\n\n```text\n...\n├ .github\n│ ├ workflows\n| | | deploy.yml\n├ src\n...\n```\n```yml\n# .github/workflows/deploy.yml\n\nname: Build and deploy\non:\n    push:\n      branches: \n        # Únicamente cuando actualicemos master\n        - master\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout 🛎️\n        uses: actions/checkout@v2.3.1\n        with:\n          persist-credentials: false\n      - name: Install and build\n        run: |\n          npm install\n          npm run export\n      - name: Deploy 🚀\n        uses: JamesIves/github-pages-deploy-action@3.5.9\n        with:\n          # Limpiará el despliegue previo\n          CLEAN: true\n          # Necesitamos crear este secret para el repositorio\n          GITHUB_TOKEN: ${{ secrets.DEPLOY_MARIOMENJR }}\n          BRANCH: master\n          FOLDER: __sapper__/export\n          BASE_BRANCH: master\n          REPOSITORY_NAME: mariomenjr/mariomenjr.github.io\n\n```\n\nEl archivo anterior se explica en la [documentación](https://github.com/marketplace/actions/deploy-to-github-pages) de la acción. En este post nos centraremos en un línea 1 línea: \n\n```yml\n...\njobs:\n  build-and-deploy:\n    ...\n    steps:\n      ...\n      - name: Deploy 🚀\n        ...\n        with:\n          ...\n          # Necesitamos crear este secret para el repositorio\n          GITHUB_TOKEN: ${{ secrets.DEPLOY_MARIOMENJR }}\n          ...\n```\n\nEs esta línea la que autoriza a la acción a hacer cambios al repositorio `mariomenjr/mariomenjr.github.io`.\n\nPara generar tu _Github token_, dirígete a [github.com/settings/tokens](https://github.com/settings/tokens), haz clic en el botón `Generate new token`, escribe un nombre significativo en el campo `Note`, selecciona el _checkbox_ **_repo_** y, por último, haz clic en el botón `Generate token`.\n\n![Github personal access tokens](https://imgur.com/HbbMgm7.png)\n\nNo olvides copiar el token.\n\nPor último, dirígete al repositorio del projecto para crear la variable de entorno que incluirás en el archivo `deploy.yml`.\n\n![Add secret to repository](https://imgur.com/iuyGLdc.png)\n\n```yml\n...\njobs:\n  build-and-deploy:\n    ...\n    steps:\n      ...\n      - name: Deploy 🚀\n        ...\n        with:\n          ...\n          # Necesitamos crear este secret para el repositorio\n          GITHUB_TOKEN: ${{ secrets.MI_VARIABLE }}\n          ...\n```\n\nListo. Tan pronto hagas push al repositorio del projecto, _Github Actions_ desplegará tu sitio estático.\n\n![Github Action Deployment](https://imgur.com/fHxzGuf.png)\n\nNo olvides activar la opción Github Pages en el repositorio al que desplegaste el sitio.\n\n![Settings](https://imgur.com/tkl8wSO.png)\n\n![Github Pages Setting](https://imgur.com/86osvtX.png)\n\n# Conclusión\n\nPuedes usar WordPress, Ghosts, incluso Jekyll si lo prefieres. El objetivo de este post es mostrarte como todas esas herramientas tienen su origen en cosas básicas que con el tiempo se convierten en herramientas robustas listas para sacarles provecho.\n\nMe decidí a construir este blog, de esta manera, para poner en práctica el concepto [Aprender en Público](https://ricardoerl.com/blog/aprender-en-publico) que presentó [Ricardo](https://ricardoerl.com), un desarrollador salvadoreño, en un charla de [Café Digital](https://twitter.com/cafedigitalsv) y así salir de mi zona de comfort. Creéme cuando te digo que me divertí.\n\n\n# Referencias\n\n- [Building a blog with Svelte, Sapper, and Markdown](https://www.mahmoudashraf.dev/blog/build-a-blog-with-svelte-and-markdown/) \n- [Sapper docs](https://sapper.svelte.dev/docs#How_it_works)\n- [Static Svelte: JavaScript Blogging with 93% less JavaScript](https://www.swyx.io/writing/svelte-static/)\n- [Markdown](https://es.wikipedia.org/wiki/Markdown)"}]