<!doctype html> <html lang=es> <head> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-174920898-1"></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-174920898-1'); </script> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <meta content=website property=og:type> <base href=/ > <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=client/main.393438101.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>#Algoritmos: Búsqueda binaria by Mario Menjívar</title><meta content="A qué alguna vez te toco buscar un número de teléfono en aquellos gigantescos directorios teléfonicos, ¿Cómo le hacías, página por página o te tratabas de ahorrar tiempo saltándote páginas?" name=description><meta content=algoritmos,computer,science,busqueda,binaria,blog,ciencias,computacion name=keywords><meta content=website property=og:type><meta content=https://mariomenjr.com/blog/2020/08/14/algoritmos-busqueda-binaria property=og:url><meta content="#Algoritmos: Búsqueda binaria by Mario Menjívar" property=og:title><meta content="A qué alguna vez te toco buscar un número de teléfono en aquellos gigantescos directorios teléfonicos, ¿Cómo le hacías, página por página o te tratabas de ahorrar tiempo saltándote páginas?" property=og:description><meta content=https://upload.wikimedia.org/wikipedia/commons/f/f7/Binary_search_into_array.png property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://mariomenjr.com/blog/2020/08/14/algoritmos-busqueda-binaria property=twitter:url><meta content="#Algoritmos: Búsqueda binaria by Mario Menjívar" property=twitter:title><meta content="A qué alguna vez te toco buscar un número de teléfono en aquellos gigantescos directorios teléfonicos, ¿Cómo le hacías, página por página o te tratabas de ahorrar tiempo saltándote páginas?" property=twitter:description><meta content=https://upload.wikimedia.org/wikipedia/commons/f/f7/Binary_search_into_array.png property=twitter:image><noscript id=sapper-head-end></noscript> </head> <body class="box-border antialiased bg-white overflow-x-hidden text-gray-900"> <div id=sapper> <div class="box-border min-h-screen min-w-screen"><div class="flex justify-between flex-col h-100" style=visibility:hidden><div><header class=px-4><div class="container mx-auto mt-2 px-2 py-4 sm:px-1 sm:py-2"><div class="flex flex-row items-center justify-between"><div class=inline-block><a href=/ ><div class="flex flex-row items-center"><img alt=@mariomenjr src="https://avatars3.githubusercontent.com/u/1946936?s=460&v=4" class="rounded-full sm:w-16 w-12"> <div class="flex flex-col ml-3"><span class="font-bold sm:text-xl text-grey-800 text-lg">Mario Menjívar</span> <span class="font-light text-grey-600 text-left text-xs">@mariomenjr</span></div></div></a></div> <div class=inline-block><div class="flex flex-row items-center"><a href=https://twitter.com/mariomenjr target=_blank><svg class="text-gray-900 fill-current h-6 w-6" viewBox="0 0 50 50" xmlns=http://www.w3.org/2000/svg><path d="M50.063 10.438a20.57 20.57 0 01-5.91 1.62 10.309 10.309 0
          004.523-5.687 20.648 20.648 0 01-6.531 2.492 10.258 10.258 0
          00-7.504-3.246c-5.68 0-10.286 4.602-10.286 10.281 0 .805.094 1.59.27
          2.344-8.547-.43-16.121-4.523-21.195-10.746a10.243 10.243 0 00-1.39
          5.172c0 3.566 1.812 6.715 4.573 8.562a10.274 10.274 0
          01-4.66-1.289v.13c0 4.984 3.547 9.136 8.246 10.085a10.29 10.29 0
          01-4.644.172c1.312 4.082 5.11 7.063 9.605 7.145A20.613 20.613 0 012.39
          41.87c-.831 0-1.648-.047-2.449-.144a29.053 29.053 0 0015.762
          4.62c18.914 0 29.258-15.667 29.258-29.253
          0-.446-.012-.895-.027-1.332a20.904 20.904 0 005.129-5.325z"></path></svg></a> <span class=w-5></span> <a href=https://linkedin.com/in/mariomenjr target=_blank><svg class="text-gray-900 fill-current h-6 w-6" viewBox="0 0 50 50" xmlns=http://www.w3.org/2000/svg><path d="M41 4H9C6.24 4 4 6.24 4 9v32c0 2.76 2.24 5 5 5h32c2.76 0 5-2.24
          5-5V9c0-2.76-2.24-5-5-5zM17 20v19h-6V20h6zm-6-5.53c0-1.4 1.2-2.47
          3-2.47s2.93 1.07 3 2.47c0 1.4-1.12 2.53-3 2.53-1.8 0-3-1.13-3-2.53zM39
          39h-6V29c0-2-1-4-3.5-4.04h-.08C27 24.96 26 27.02 26
          29v10h-6V20h6v2.56S27.93 20 31.81 20c3.97 0 7.19 2.73 7.19 8.26V39z"></path></svg></a></div></div></div></div></header> <nav class="px-4 border-b mt-2"><div class="container mx-auto"><div class="flex flex-row items-center justify-between"><ul class="flex flex-row items-center space-x-8"><li class="px-2 border-gray-900 py-2 border-b"><a href=/blog class="text-gray-900 font-light hover:text-black text-sm tracking-wide uppercase">blog</a> </li> </ul><ul class="flex flex-row items-center space-x-8"><li class="px-2 border-gray-900 py-2"><a href=/acerca class="text-gray-900 font-light hover:text-black text-sm tracking-wide uppercase">acerca</a> </li> </ul></div></div></nav></div> <div class="px-4 bg-gray-200"><div class="container mx-auto"><div class="gap-2 grid grid-cols-4"><div class="col-span-4 sm:col-span-3"><div class=box-border><main class=py-8> <p class=c-label-last-updated>Última actualización en 8/14/2020, 4:47:12 PM por Mario Menjívar</p> <a href="https://twitter.com/share?ref_src=twsrc%5Etfw&text=hola&via=mariomenjr" class=twitter-share-button data-show-count=false>Tweet </a> <article class=c-article><h1 id=algoritmos-búsqueda-binaria>#Algoritmos: Búsqueda binaria</h1> <p>A qué alguna vez te toco buscar un número de teléfono en aquellos gigantescos directorios teléfonicos, ¿Cómo le hacías, página por página o tratabas de ahorrar tiempo saltándote páginas?</p> <h2 id=la-idea>La idea</h2> <p>Retomando el gigantesco directorio teléfonico, podemos estar seguros de una cosa: los números de teléfono se presentan en orden alfabético por el nombre del propietario. Esto es es imprecindible para el algoritmo de búsqueda binaria. </p> <p>Suponiendo que buscamos el número teléfonico de Juan, ¿Tiene sentido empezar desde las primeras páginas dónde estarán los números de personas cómo Alberto o Alejandra? Si tu respuesta es no, estás en lo correcto, será muchísimo más fácil identificar en cuál página empiezan a listarse los nombres que inician con J, y empezar nuestra búsqueda desde ahí. Una vez en esta página, podríamos incluso tratar de idéntificar en cuál página empiezan a listarse los nombres que empiezan con Ju, y así sucesivamente hasta encontrar a Juan.</p> <h2 id=en-código>En código</h2> <p>Pero en este blog nosotros ya no usamos esos gigantescos directorios teléfonicos, así que vamos a ver un ejemplo más acorde a lo que sabemos hacer aquí: código. Por lo qué para nuestro ejemplo práctico, vamos a validar si un número <code>X</code> está incluído dentro de una lista de <code>N</code> elementos.</p> <p>Como mencionamos antes en el ejemplo del directorio, podíamos estar seguros de una cosa: sus datos están ordenados. Esto se mantiene a la hora de utilizar código. Nuestro arreglo de datos debe estar ordenado. Sino lo está, debemos ordenarlo. Eso lo dejaremos para futuros posts.</p> <p>Esta será nuestra lista de trabajo:</p> <pre class="language-javascript overflow-x-auto"><code><span class=hljs-keyword>const</span> numbers = [<span class=hljs-number>2</span>, <span class=hljs-number>3</span>, <span class=hljs-number>5</span>, <span class=hljs-number>9</span>, <span class=hljs-number>15</span>, <span class=hljs-number>17</span>, <span class=hljs-number>55</span>, <span class=hljs-number>69</span>];</code></pre><p>Para ejecutar de manera efectiva el algoritmo, necesitaremos tener la noción del mayor y menor número en nuestra lista, y ya qué no hay mejor manera de localizar valores en una lista que usar su indice, guardaremos eso, los indices:</p> <pre class="language-javascript overflow-x-auto"><code><span class=hljs-keyword>let</span> maxIndex = numbers.length - <span class=hljs-number>1</span>;
<span class=hljs-keyword>let</span> minIndex = <span class=hljs-number>0</span>;</code></pre><p>¿Recuerdas como en el ejemplo del directorio, tratabamos de identificar la página en la cuál los nombres que inician con J empezaban a listarse? Al aplicar el algoritmo de búsqueda binaria tomamos un enfoque más general. Esto significa que nosotros siempre dividiremos la lista por la mitad y, partiendo de una comparación, definiremos a cuál de las dos mitades pertence el valor que deseamos encontrar. Una vez conozcamos la mitad a la qué pertenece, repetimos el proceso y así sucesivamente hasta que nuestra área de búsqueda se reduce a uno, o simplemente no encontramos el valor.</p> <blockquote> <p><img alt="Búsqueda binaria" src=https://upload.wikimedia.org/wikipedia/commons/f/f7/Binary_search_into_array.png> Este es el esquema del funcionamiento del algoritmo de <a href=https://es.wikipedia.org/wiki/B%C3%BAsqueda_binaria>Wikipedia</a></p> </blockquote> <p>Antes de ejemplificar lo anterior, nos queda mostrar cómo identificaremos la mitad de nuestra lista:</p> <pre class="language-javascript overflow-x-auto"><code><span class=hljs-keyword>let</span> half = <span class=hljs-built_in>Math</span>.floor((minIndex + maxIndex)/<span class=hljs-number>2</span>);</code></pre><p>Ahora sí, armemos el algoritmo:</p> <pre class="language-javascript overflow-x-auto"><code><span class=hljs-keyword>const</span> find = <span class=hljs-number>17</span>;
<span class=hljs-keyword>const</span> numbers = [<span class=hljs-number>2</span>, <span class=hljs-number>3</span>, <span class=hljs-number>5</span>, <span class=hljs-number>9</span>, <span class=hljs-number>15</span>, <span class=hljs-number>17</span>, <span class=hljs-number>55</span>, <span class=hljs-number>69</span>];

<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>busquedaBinaria</span>(<span class=hljs-params>collection, findee</span>) </span>{
  <span class=hljs-comment>// Asignando los valores del rango inicial</span>
  <span class=hljs-keyword>let</span> minIndex = <span class=hljs-number>0</span>;
  <span class=hljs-keyword>let</span> maxIndex = numbers.length - <span class=hljs-number>1</span>;

  <span class=hljs-keyword>while</span> (minIndex &lt;= maxIndex) {

    <span class=hljs-comment>// Calculando la posición en el medio de la lista</span>
    <span class=hljs-keyword>let</span> half = <span class=hljs-built_in>Math</span>.floor((minIndex + maxIndex) / <span class=hljs-number>2</span>);

    <span class=hljs-comment>// Recoger el valor del medio</span>
    <span class=hljs-keyword>let</span> guess = collection[half];

    <span class=hljs-keyword>if</span> (guess === findee) <span class=hljs-comment>// Comparamos si es el valor que buscamos</span>
      <span class=hljs-keyword>return</span> half;

    <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (guess > findee) 
      <span class=hljs-comment>// Si el valor que buscamos es menor al valor supuesto</span>
      <span class=hljs-comment>// debemos reducir nuestro rango de búsqueda.</span>
      <span class=hljs-comment>// Ahora nuestro mayor valor está justo debajo de la mitad calculada.</span>
      maxIndex = half - <span class=hljs-number>1</span>; 

    <span class=hljs-keyword>else</span> 
      <span class=hljs-comment>// Si el valor que buscamos es mayor al valor supuesto</span>
      <span class=hljs-comment>// debemos reducir nuestro rango de búsqueda.</span>
      <span class=hljs-comment>// Ahora nuestro menor valor está justo arriba de la mitad calculada.</span>
      minIndex = half + <span class=hljs-number>1</span>;
  }
  <span class=hljs-keyword>return</span> <span class=hljs-number>-1</span>;
}

<span class=hljs-keyword>const</span> foundIndex = busquedaBinaria(numbers, find);
<span class=hljs-built_in>console</span>.log(
  foundIndex === <span class=hljs-number>-1</span>
    ? <span class=hljs-string>`El número <span class=hljs-subst>${find}</span> no fue encontrado.`</span>
    : <span class=hljs-string>`El número <span class=hljs-subst>${find}</span> está en el índice <span class=hljs-subst>${foundIndex}</span>.`</span>
);</code></pre><p>Es esta dinámica de decidir únicamente entre dos opciones, cada vez que reducimos el área de búsqueda, lo qué le da el nombre algoritmo.</p> <h1 id=conclusión>Conclusión</h1> <p>Pudimos simplemente ejecutar el siguiente código:</p> <pre class="language-javascript overflow-x-auto"><code><span class=hljs-keyword>const</span> find = <span class=hljs-number>17</span>;
<span class=hljs-keyword>const</span> numbers = [<span class=hljs-number>2</span>, <span class=hljs-number>3</span>, <span class=hljs-number>5</span>, <span class=hljs-number>9</span>, <span class=hljs-number>15</span>, <span class=hljs-number>17</span>, <span class=hljs-number>55</span>, <span class=hljs-number>69</span>];

<span class=hljs-keyword>let</span> foundIndex = <span class=hljs-number>-1</span>;

<span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> index = <span class=hljs-number>0</span>; index &lt; numbers.length; index++) {
  <span class=hljs-keyword>if</span> (find === numbers[index]) {
    foundIndex = index;
    <span class=hljs-keyword>break</span>;
  }
}

<span class=hljs-built_in>console</span>.log(
  foundIndex === <span class=hljs-number>-1</span>
    ? <span class=hljs-string>`El número <span class=hljs-subst>${find}</span> no fue encontrado.`</span>
    : <span class=hljs-string>`El número <span class=hljs-subst>${find}</span> está en el índice <span class=hljs-subst>${foundIndex}</span>.`</span>
);</code></pre><p>Comparar cada uno de los <code>items</code> en la lista y, cuando lo encontramos, listo. Podrías pensar que es enfoque es muchísimo más fácil y rápido de programar, y tienes razón. Pero, ¿Qué pasa cuando nuestra lista no contiene 8 <code>items</code> sino 1,000,000?</p> <p>La intención de este post es mostrarte que, si bien es cierto en programación hay muchas formas de resolver un problema, nuestro objetivo conforme avanzamos en nuestra carrera es escogar la más óptima. Cada problema es un mundo y es nuestro trabajo encontrar la mejor solución.</p> <h1 id=referencias>Referencias</h1> <ul> <li><a href=https://en.wikipedia.org/wiki/Binary_search_algorithm>Binary search algorithm from Wikipedia</a></li> <li><a href=https://www.goodreads.com/book/show/22847284-grokking-algorithms-an-illustrated-guide-for-programmers-and-other-curio>Grokking Algorithms: An Illustrated Guide For Programmers and Other Curious People</a></li> </ul> </article></main></div></div> <div class="col-span-4 sm:col-span-1"><div class=box-border><main class=py-8><p class="text-xs text-gray-400 tracking-wide uppercase">No entries</main></div></div></div></div></div> <footer class="box-border border-t px-4"><div class="container mx-auto py-8 text-sm">2020 © Mario Menjívar</div></footer></div></div></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{author:"Mario Menjívar",slug:"algoritmos-busqueda-binaria",title:"#Algoritmos: Búsqueda binaria",timestamp:"2020-08-14T09:47:12.000-07:00",brief:"A qué alguna vez te toco buscar un número de teléfono en aquellos gigantescos directorios teléfonicos, ¿Cómo le hacías, página por página o te tratabas de ahorrar tiempo saltándote páginas?",keywords:"algoritmos,computer,science,busqueda,binaria,blog,ciencias,computacion",cover:"https:\u002F\u002Fupload.wikimedia.org\u002Fwikipedia\u002Fcommons\u002Ff\u002Ff7\u002FBinary_search_into_array.png",endpoint:"2020\u002F08\u002F14\u002Falgoritmos-busqueda-binaria",content:"\u003Ch1 id=\"algoritmos-búsqueda-binaria\"\u003E#Algoritmos: Búsqueda binaria\u003C\u002Fh1\u003E\n\u003Cp\u003EA qué alguna vez te toco buscar un número de teléfono en aquellos gigantescos directorios teléfonicos, ¿Cómo le hacías, página por página o tratabas de ahorrar tiempo saltándote páginas?\u003C\u002Fp\u003E\n\u003Ch2 id=\"la-idea\"\u003ELa idea\u003C\u002Fh2\u003E\n\u003Cp\u003ERetomando el gigantesco directorio teléfonico, podemos estar seguros de una cosa: los números de teléfono se presentan en orden alfabético por el nombre del propietario. Esto es es imprecindible para el algoritmo de búsqueda binaria. \u003C\u002Fp\u003E\n\u003Cp\u003ESuponiendo que buscamos el número teléfonico de Juan, ¿Tiene sentido empezar desde las primeras páginas dónde estarán los números de personas cómo Alberto o Alejandra? Si tu respuesta es no, estás en lo correcto, será muchísimo más fácil identificar en cuál página empiezan a listarse los nombres que inician con J, y empezar nuestra búsqueda desde ahí. Una vez en esta página, podríamos incluso tratar de idéntificar en cuál página empiezan a listarse los nombres que empiezan con Ju, y así sucesivamente hasta encontrar a Juan.\u003C\u002Fp\u003E\n\u003Ch2 id=\"en-código\"\u003EEn código\u003C\u002Fh2\u003E\n\u003Cp\u003EPero en este blog nosotros ya no usamos esos gigantescos directorios teléfonicos, así que vamos a ver un ejemplo más acorde a lo que sabemos hacer aquí: código. Por lo qué para nuestro ejemplo práctico, vamos a validar si un número \u003Ccode\u003EX\u003C\u002Fcode\u003E está incluído dentro de una lista de \u003Ccode\u003EN\u003C\u002Fcode\u003E elementos.\u003C\u002Fp\u003E\n\u003Cp\u003EComo mencionamos antes en el ejemplo del directorio, podíamos estar seguros de una cosa: sus datos están ordenados. Esto se mantiene a la hora de utilizar código. Nuestro arreglo de datos debe estar ordenado. Sino lo está, debemos ordenarlo. Eso lo dejaremos para futuros posts.\u003C\u002Fp\u003E\n\u003Cp\u003EEsta será nuestra lista de trabajo:\u003C\u002Fp\u003E\n\u003Cpre class='language-javascript overflow-x-auto'\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E numbers = [\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E5\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E9\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E15\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E17\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E55\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E69\u003C\u002Fspan\u003E];\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EPara ejecutar de manera efectiva el algoritmo, necesitaremos tener la noción del mayor y menor número en nuestra lista, y ya qué no hay mejor manera de localizar valores en una lista que usar su indice, guardaremos eso, los indices:\u003C\u002Fp\u003E\n\u003Cpre class='language-javascript overflow-x-auto'\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E maxIndex = numbers.length - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E;\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E minIndex = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E¿Recuerdas como en el ejemplo del directorio, tratabamos de identificar la página en la cuál los nombres que inician con J empezaban a listarse? Al aplicar el algoritmo de búsqueda binaria tomamos un enfoque más general. Esto significa que nosotros siempre dividiremos la lista por la mitad y, partiendo de una comparación, definiremos a cuál de las dos mitades pertence el valor que deseamos encontrar. Una vez conozcamos la mitad a la qué pertenece, repetimos el proceso y así sucesivamente hasta que nuestra área de búsqueda se reduce a uno, o simplemente no encontramos el valor.\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fupload.wikimedia.org\u002Fwikipedia\u002Fcommons\u002Ff\u002Ff7\u002FBinary_search_into_array.png\" alt=\"Búsqueda binaria\"\u003E\nEste es el esquema del funcionamiento del algoritmo de \u003Ca href=\"https:\u002F\u002Fes.wikipedia.org\u002Fwiki\u002FB%C3%BAsqueda_binaria\"\u003EWikipedia\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003EAntes de ejemplificar lo anterior, nos queda mostrar cómo identificaremos la mitad de nuestra lista:\u003C\u002Fp\u003E\n\u003Cpre class='language-javascript overflow-x-auto'\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E half = \u003Cspan class=\"hljs-built_in\"\u003EMath\u003C\u002Fspan\u003E.floor((minIndex + maxIndex)\u002F\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EAhora sí, armemos el algoritmo:\u003C\u002Fp\u003E\n\u003Cpre class='language-javascript overflow-x-auto'\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E find = \u003Cspan class=\"hljs-number\"\u003E17\u003C\u002Fspan\u003E;\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E numbers = [\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E5\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E9\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E15\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E17\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E55\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E69\u003C\u002Fspan\u003E];\n\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EbusquedaBinaria\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Ecollection, findee\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Asignando los valores del rango inicial\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E minIndex = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E;\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E maxIndex = numbers.length - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E;\n\n  \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E (minIndex &lt;= maxIndex) {\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Calculando la posición en el medio de la lista\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E half = \u003Cspan class=\"hljs-built_in\"\u003EMath\u003C\u002Fspan\u003E.floor((minIndex + maxIndex) \u002F \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E);\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Recoger el valor del medio\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E guess = collection[half];\n\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (guess === findee) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Comparamos si es el valor que buscamos\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E half;\n\n    \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (guess &gt; findee) \n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Si el valor que buscamos es menor al valor supuesto\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F debemos reducir nuestro rango de búsqueda.\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Ahora nuestro mayor valor está justo debajo de la mitad calculada.\u003C\u002Fspan\u003E\n      maxIndex = half - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E; \n\n    \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Si el valor que buscamos es mayor al valor supuesto\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F debemos reducir nuestro rango de búsqueda.\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Ahora nuestro menor valor está justo arriba de la mitad calculada.\u003C\u002Fspan\u003E\n      minIndex = half + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E;\n  }\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E-1\u003C\u002Fspan\u003E;\n}\n\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E foundIndex = busquedaBinaria(numbers, find);\n\u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(\n  foundIndex === \u003Cspan class=\"hljs-number\"\u003E-1\u003C\u002Fspan\u003E\n    ? \u003Cspan class=\"hljs-string\"\u003E`El número \u003Cspan class=\"hljs-subst\"\u003E${find}\u003C\u002Fspan\u003E no fue encontrado.`\u003C\u002Fspan\u003E\n    : \u003Cspan class=\"hljs-string\"\u003E`El número \u003Cspan class=\"hljs-subst\"\u003E${find}\u003C\u002Fspan\u003E está en el índice \u003Cspan class=\"hljs-subst\"\u003E${foundIndex}\u003C\u002Fspan\u003E.`\u003C\u002Fspan\u003E\n);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EEs esta dinámica de decidir únicamente entre dos opciones, cada vez que reducimos el área de búsqueda, lo qué le da el nombre algoritmo.\u003C\u002Fp\u003E\n\u003Ch1 id=\"conclusión\"\u003EConclusión\u003C\u002Fh1\u003E\n\u003Cp\u003EPudimos simplemente ejecutar el siguiente código:\u003C\u002Fp\u003E\n\u003Cpre class='language-javascript overflow-x-auto'\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E find = \u003Cspan class=\"hljs-number\"\u003E17\u003C\u002Fspan\u003E;\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E numbers = [\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E5\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E9\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E15\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E17\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E55\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E69\u003C\u002Fspan\u003E];\n\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E foundIndex = \u003Cspan class=\"hljs-number\"\u003E-1\u003C\u002Fspan\u003E;\n\n\u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E index = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; index &lt; numbers.length; index++) {\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (find === numbers[index]) {\n    foundIndex = index;\n    \u003Cspan class=\"hljs-keyword\"\u003Ebreak\u003C\u002Fspan\u003E;\n  }\n}\n\n\u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(\n  foundIndex === \u003Cspan class=\"hljs-number\"\u003E-1\u003C\u002Fspan\u003E\n    ? \u003Cspan class=\"hljs-string\"\u003E`El número \u003Cspan class=\"hljs-subst\"\u003E${find}\u003C\u002Fspan\u003E no fue encontrado.`\u003C\u002Fspan\u003E\n    : \u003Cspan class=\"hljs-string\"\u003E`El número \u003Cspan class=\"hljs-subst\"\u003E${find}\u003C\u002Fspan\u003E está en el índice \u003Cspan class=\"hljs-subst\"\u003E${foundIndex}\u003C\u002Fspan\u003E.`\u003C\u002Fspan\u003E\n);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EComparar cada uno de los \u003Ccode\u003Eitems\u003C\u002Fcode\u003E en la lista y, cuando lo encontramos, listo. Podrías pensar que es enfoque es muchísimo más fácil y rápido de programar, y tienes razón. Pero, ¿Qué pasa cuando nuestra lista no contiene 8 \u003Ccode\u003Eitems\u003C\u002Fcode\u003E sino 1,000,000?\u003C\u002Fp\u003E\n\u003Cp\u003ELa intención de este post es mostrarte que, si bien es cierto en programación hay muchas formas de resolver un problema, nuestro objetivo conforme avanzamos en nuestra carrera es escogar la más óptima. Cada problema es un mundo y es nuestro trabajo encontrar la mejor solución.\u003C\u002Fp\u003E\n\u003Ch1 id=\"referencias\"\u003EReferencias\u003C\u002Fh1\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FBinary_search_algorithm\"\u003EBinary search algorithm from Wikipedia\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.goodreads.com\u002Fbook\u002Fshow\u002F22847284-grokking-algorithms-an-illustrated-guide-for-programmers-and-other-curio\"\u003EGrokking Algorithms: An Illustrated Guide For Programmers and Other Curious People\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.76daedad.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main","/client/client.76daedad.js")}document.head.appendChild(s)</script> 