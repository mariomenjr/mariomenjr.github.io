{"author":"Mario Menjívar","slug":"algoritmos-busqueda-binaria","title":"#Algoritmos: Búsqueda binaria","timestamp":"2020-08-14T09:47:12.000-07:00","brief":"A qué alguna vez te toco buscar un número de teléfono en aquellos gigantescos directorios teléfonicos, ¿Cómo le hacías, página por página o te tratabas de ahorrar tiempo saltándote páginas?","keywords":"algoritmos,computer,science,busqueda,binaria,blog,ciencias,computacion","cover":"https://upload.wikimedia.org/wikipedia/commons/f/f7/Binary_search_into_array.png","endpoint":"2020/08/14/algoritmos-busqueda-binaria","content":"<h1 id=\"algoritmos-búsqueda-binaria\">#Algoritmos: Búsqueda binaria</h1>\n<p>A qué alguna vez te toco buscar un número de teléfono en aquellos gigantescos directorios teléfonicos, ¿Cómo le hacías, página por página o tratabas de ahorrar tiempo saltándote páginas?</p>\n<h2 id=\"la-idea\">La idea</h2>\n<p>Retomando el gigantesco directorio teléfonico, podemos estar seguros de una cosa: los números de teléfono se presentan en orden alfabético por el nombre del propietario. Esto es es imprecindible para el algoritmo de búsqueda binaria. </p>\n<p>Suponiendo que buscamos el número teléfonico de Juan, ¿Tiene sentido empezar desde las primeras páginas dónde estarán los números de personas cómo Alberto o Alejandra? Si tu respuesta es no, estás en lo correcto, será muchísimo más fácil identificar en cuál página empiezan a listarse los nombres que inician con J, y empezar nuestra búsqueda desde ahí. Una vez en esta página, podríamos incluso tratar de idéntificar en cuál página empiezan a listarse los nombres que empiezan con Ju, y así sucesivamente hasta encontrar a Juan.</p>\n<h2 id=\"en-código\">En código</h2>\n<p>Pero en este blog nosotros ya no usamos esos gigantescos directorios teléfonicos, así que vamos a ver un ejemplo más acorde a lo que sabemos hacer aquí: código. Por lo qué para nuestro ejemplo práctico, vamos a validar si un número <code>X</code> está incluído dentro de una lista de <code>N</code> elementos.</p>\n<p>Como mencionamos antes en el ejemplo del directorio, podíamos estar seguros de una cosa: sus datos están ordenados. Esto se mantiene a la hora de utilizar código. Nuestro arreglo de datos debe estar ordenado. Sino lo está, debemos ordenarlo. Eso lo dejaremos para futuros posts.</p>\n<p>Esta será nuestra lista de trabajo:</p>\n<pre class='language-javascript'><code class=\"hljs\"><span class=\"hljs-keyword\">const</span> numbers = [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">17</span>, <span class=\"hljs-number\">55</span>, <span class=\"hljs-number\">69</span>];</code></pre><p>Para ejecutar de manera efectiva el algoritmo, necesitaremos tener la noción del mayor y menor número en nuestra lista, y ya qué no hay mejor manera de localizar valores en una lista que usar su indice, guardaremos eso, los indices:</p>\n<pre class='language-javascript'><code class=\"hljs\"><span class=\"hljs-keyword\">let</span> maxIndex = numbers.length - <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">let</span> minIndex = <span class=\"hljs-number\">0</span>;</code></pre><p>¿Recuerdas como en el ejemplo del directorio, tratabamos de identificar la página en la cuál los nombres que inician con J empezaban a listarse? Al aplicar el algoritmo de búsqueda binaria tomamos un enfoque más general. Esto significa que nosotros siempre dividiremos la lista por la mitad y, partiendo de una comparación, definiremos a cuál de las dos mitades pertence el valor que deseamos encontrar. Una vez conozcamos la mitad a la qué pertenece, repetimos el proceso y así sucesivamente hasta que nuestra área de búsqueda se reduce a uno, o simplemente no encontramos el valor.</p>\n<blockquote>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/f/f7/Binary_search_into_array.png\" alt=\"Búsqueda binaria\">\nEste es el esquema del funcionamiento del algoritmo de <a href=\"https://es.wikipedia.org/wiki/B%C3%BAsqueda_binaria\">Wikipedia</a></p>\n</blockquote>\n<p>Antes de ejemplificar lo anterior, nos queda mostrar cómo identificaremos la mitad de nuestra lista:</p>\n<pre class='language-javascript'><code class=\"hljs\"><span class=\"hljs-keyword\">let</span> half = <span class=\"hljs-built_in\">Math</span>.floor((minIndex + maxIndex)/<span class=\"hljs-number\">2</span>);</code></pre><p>Ahora sí, armemos el algoritmo:</p>\n<pre class='language-javascript'><code class=\"hljs\"><span class=\"hljs-keyword\">const</span> find = <span class=\"hljs-number\">17</span>;\n<span class=\"hljs-keyword\">const</span> numbers = [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">17</span>, <span class=\"hljs-number\">55</span>, <span class=\"hljs-number\">69</span>];\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">busquedaBinaria</span>(<span class=\"hljs-params\">collection, findee</span>) </span>{\n  <span class=\"hljs-comment\">// Asignando los valores del rango inicial</span>\n  <span class=\"hljs-keyword\">let</span> minIndex = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">let</span> maxIndex = numbers.length - <span class=\"hljs-number\">1</span>;\n\n  <span class=\"hljs-keyword\">while</span> (minIndex &lt;= maxIndex) {\n\n    <span class=\"hljs-comment\">// Calculando la posición en el medio de la lista</span>\n    <span class=\"hljs-keyword\">let</span> half = <span class=\"hljs-built_in\">Math</span>.floor((minIndex + maxIndex) / <span class=\"hljs-number\">2</span>);\n\n    <span class=\"hljs-comment\">// Recoger el valor del medio</span>\n    <span class=\"hljs-keyword\">let</span> guess = collection[half];\n\n    <span class=\"hljs-keyword\">if</span> (guess === findee) <span class=\"hljs-comment\">// Comparamos si es el valor que buscamos</span>\n      <span class=\"hljs-keyword\">return</span> half;\n\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (guess &gt; findee) \n      <span class=\"hljs-comment\">// Si el valor que buscamos es menor al valor supuesto</span>\n      <span class=\"hljs-comment\">// debemos reducir nuestro rango de búsqueda.</span>\n      <span class=\"hljs-comment\">// Ahora nuestro mayor valor está justo debajo de la mitad calculada.</span>\n      maxIndex = half - <span class=\"hljs-number\">1</span>; \n\n    <span class=\"hljs-keyword\">else</span> \n      <span class=\"hljs-comment\">// Si el valor que buscamos es mayor al valor supuesto</span>\n      <span class=\"hljs-comment\">// debemos reducir nuestro rango de búsqueda.</span>\n      <span class=\"hljs-comment\">// Ahora nuestro menor valor está justo arriba de la mitad calculada.</span>\n      minIndex = half + <span class=\"hljs-number\">1</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n}\n\n<span class=\"hljs-keyword\">const</span> foundIndex = busquedaBinaria(numbers, find);\n<span class=\"hljs-built_in\">console</span>.log(\n  foundIndex === -<span class=\"hljs-number\">1</span>\n    ? <span class=\"hljs-string\">`El número <span class=\"hljs-subst\">${find}</span> no fue encontrado.`</span>\n    : <span class=\"hljs-string\">`El número <span class=\"hljs-subst\">${find}</span> está en el índice <span class=\"hljs-subst\">${foundIndex}</span>.`</span>\n);</code></pre><p>Es esta dinámica de decidir únicamente entre dos opciones, cada vez que reducimos el área de búsqueda, lo qué le da el nombre algoritmo.</p>\n<h1 id=\"conclusión\">Conclusión</h1>\n<p>Pudimos simplemente ejecutar el siguiente código:</p>\n<pre class='language-javascript'><code class=\"hljs\"><span class=\"hljs-keyword\">const</span> find = <span class=\"hljs-number\">17</span>;\n<span class=\"hljs-keyword\">const</span> numbers = [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">17</span>, <span class=\"hljs-number\">55</span>, <span class=\"hljs-number\">69</span>];\n\n<span class=\"hljs-keyword\">let</span> foundIndex = -<span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>; index &lt; numbers.length; index++) {\n  <span class=\"hljs-keyword\">if</span> (find === numbers[index]) {\n    foundIndex = index;\n    <span class=\"hljs-keyword\">break</span>;\n  }\n}\n\n<span class=\"hljs-built_in\">console</span>.log(\n  foundIndex === -<span class=\"hljs-number\">1</span>\n    ? <span class=\"hljs-string\">`El número <span class=\"hljs-subst\">${find}</span> no fue encontrado.`</span>\n    : <span class=\"hljs-string\">`El número <span class=\"hljs-subst\">${find}</span> está en el índice <span class=\"hljs-subst\">${foundIndex}</span>.`</span>\n);</code></pre><p>Comparar cada uno de los <code>items</code> en la lista y, cuando lo encontramos, listo. Podrías pensar que es enfoque es muchísimo más fácil y rápido de programar, y tienes razón. Pero, ¿Qué pasa cuando nuestra lista no contiene 8 <code>items</code> sino 1,000,000?</p>\n<p>La intención de este post es mostrarte que, si bien es cierto en programación hay muchas formas de resolver un problema, nuestro objetivo conforme avanzamos en nuestra carrera es escogar la más óptima. Cada problema es un mundo y es nuestro trabajo encontrar la mejor solución.</p>\n<h1 id=\"referencias\">Referencias</h1>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Binary_search_algorithm\">Binary search algorithm from Wikipedia</a></li>\n<li><a href=\"https://www.goodreads.com/book/show/22847284-grokking-algorithms-an-illustrated-guide-for-programmers-and-other-curio\">Grokking Algorithms: An Illustrated Guide For Programmers and Other Curious People</a></li>\n</ul>\n"}